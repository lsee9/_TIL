###### 210609_wed

##### 필기만 한거... 정리중!

<hr>



###### 오늘의 목차 :lemon:

#### Basic Syntax

- Java 프로그램의 실행 구조 
- 변수 
- 기본 자료형 :heavy_check_mark:
- 특수 문자와 서식 문자
- 연산자
- 배열
- 배열과 메모리
- 조건문
- 반복문

###### 자료형을 알아야 변수를 사용할 수 있다 :lollipop:

<hr>

<br>

# 3. 자료형(Data Type)

> 데이터가 메모리에서 차지하는 크기에 대해 학습합시다!!



## 3.1 기본자료형과 객체자료형

###### 중요!!!!

자료형은 2가지로 구분

- 기본 자료형 (Primitive Data Type) : 데이터가 변수에 직접 저장
  - 전체 메모리 공간에 변수 만들어서 데이터 저장 -> 일정한 공간에 데이터가 저장됨
  - int i = 10;
    - 메모리에 i라는 일정 공간 만들고, 그곳에 데이터 10이 들어감
    - 숫자 boolean등 데이터가 직접 들어감
  - 정수, 실수, 문자, 문자열, 불리언(참 거짓)
  - 직접 들어가는게 핵심!!!
  - 
- 객체 자료형(reference type) : 객체 메모리 주소가 변수에 저장
  - 메모리가 있음
  - 객체 (자전거, 계산기라는 객체가 존재)
  - 객체들이 메모리에 담겨있음
  - 객체를 가르키는 i를 만듦
  - i에 내가 만든 객체가 바로 들어가는 것이 아니라, 객체가 존재하는 메모리는 따로 있고, 이 객체를 가르키는 다른 메모리 값을 잡음
    - 객체가 존재하는 메모리의 주소값을 가짐

- 기본 : 변수 선언하면, 선언한 변수에 공간 할당되고, 초기화를 거쳐 데이터 바로 들어감
- 객체 : 객체를 담아놓고 다른곳에 변수를 만듦, 객체가 있는 메모리의 주소를 그 변수에 담음
  - 즉, i는 객체의 주소를 담은 메모리를 가르킴
  - 참조한다고 함!!! (레퍼런스)
  - 중요!!!!
  - 실제 객체를 담는 것이 아니라 객체가 담긴 메모리 주소를 갖고 있다
  - 항상 레퍼런스의 크기는 4byte로 정해져 있다!!! (항상 주소만 들어가기 때문)

## 3.2 Java 기본자료형

- 기본 자료형

  - 정수

    - 바이트 : 메모리에서 1바이트 차지 = 8bit

      -128 ~ +127, 256개의 정수만 받을 수 있음

      표현할 수 있는 숫자가 너무 적음(잘 사용하지 않음)

      128부터는 누실됨 => overflow 발생

    - char 16bit

      A, a이런 단일 문자 하나하나

      엄청 많이 쓰진 않음

    - short

      byte보다는 큼, 그러나 큰 숫자 표현 X, 잘 쓰지는 않음

    ##### A, a이런것도 아스키 코드로 변환해서 컴퓨터에서 표현됨 (0, 1로만 표현되기때문), 그래서 char도 정수형으로 분류함

    

    - int

      32bit

      실생활에서 필요한 숫자는 ㄴ32bit에서 전부 표현가능

      많이 씀

    - long

      64bit

      실생활에서 쓰지않는 큰 숫자까지 취급됨

    ##### 파란색으로 표시한게 많이 쓰임

    그중 int가 가장 많이 씀ㄴ

    

  - 실수 : 3.14, 1.78이런식으로 실수형으로 표현되는 것

    - float
    - double

    ##### double가 더 많이 쓰임!

    프로그래밍하면서 필요한 모든 소수점 표현 가능

  - 논리

    - boolean : 참 / 거짓

      C계열 : 0을 false, 0이 아닌수 true

      C++ : true, false

      Java도 true, false가 존재함

      1바이트

  - 문자열???

    - **String** 이라는 자료형 사용

    - String str = "ABCD"

      기본 자료형 X, **객체 자료형**!!!

      4byte크기가짐!!!

      다른 곳에 String값을 만들어놓고, str은 따로 만들어서 ABCD가 가진 객체의 주소를 str에 저장해둠

#### 실행하기

- Java 프로젝트 생성

- class : 시작 첫단어는 대문자
- 작성함
- 메모리 할당되고 데이터가 저장된다, 이걸 불러서 출력할 수 있음
- 문자열도 그냥 바꾸면 바뀐 값이 출력
- 변수에 담은 데이터는 언제나 변경 가능

```java
package dataFormat;

public class MainClass {
	public static void main(String[] args) {
		char c = 'a';
		System.out.println("c = " + c);
		
		int i  = 10;
		System.out.println("i = " + i);
		
		double d = 10.123;
		System.out.println("d = "+ d);
		
		boolean b = false;
		System.out.println("b = " + b);
		
		String s = "Hello Java World";
		System.out.println("s = " + s);
		//원래 객체 생성할때는 new로 객체를 선언해주고 시작해야하는데
		//워낙 많이 쓰여서 선언해주고 대입연산자로 값을 넣을 수 있도록 만들어줌
//		String str = new String();
		
	}
}

c = a
i = 10
d = 10.123
b = false
s = Hello Java World
```



## 3.3 형 변환

> 형이 변화함

- int => long으로 확장
- long => 작은 형태로 변환
- 자동적 형변환 (묵시적 형변환)
  - 작은 => 큰 으로 가는 경우
  - by를 int로 대입함
  - 1마이트 => 4바이트
  - 아무런 문제없이 들어감
  - 그대로 10이 출력됨
  - 작은 데이터가 큰 공간으로 옮겨감
- 명시적 형변환
  - 큰 => 작은
  - int => byte
  - 4바이트 => 1바이트
  - 100이라는 숫자가 1마이츠로 들어가기 위해서는 ()로 byte로 형변환되어 들어가야함을 명시적으로 작성해줘야함
  - 4byte가 1byte로 들어가려다보니까 누실이 생김!!!
  - 100은 그렇게 큰 수가 아니라 정상적으로 들어감
  - ivar = 123456 십이만
    - 1바이트 공간에 전부 못들어감
    - 들어갈 수 있는 만큰만 들어가고 전부 날아감
    - 64로 깎여버림
  - 명시를 해줘서 형변환 해야하는데, 잘못하면 데이터가 누실될 수 있다
  - 그래서 형변환을 해야하는 경우 발생할 수 있는데, 처음부터 큰 자료형을 주로 사용함